{"ast":null,"code":"const GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\nconst API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/';\nconst MODEL_NAME = 'gemini-pro-latest';\nasync function callGeminiAPI(prompt, systemPrompt, responseSchema) {\n  var _result$candidates, _result$candidates$, _result$candidates$$c, _result$candidates$$c2, _result$candidates$$c3;\n  if (!GEMINI_API_KEY) {\n    throw new Error('Gemini API Key is missing. Please check your .env file.');\n  }\n  const apiUrl = `${API_BASE_URL}${MODEL_NAME}:generateContent?key=${GEMINI_API_KEY}`;\n  const payload = {\n    contents: [{\n      parts: [{\n        text: prompt\n      }]\n    }],\n    systemInstruction: {\n      parts: [{\n        text: systemPrompt\n      }]\n    },\n    generationConfig: {\n      responseMimeType: \"application/json\",\n      responseSchema: responseSchema\n    }\n  };\n  const response = await fetch(apiUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(payload)\n  });\n  if (!response.ok) {\n    var _error$error;\n    const error = await response.json();\n    throw new Error(((_error$error = error.error) === null || _error$error === void 0 ? void 0 : _error$error.message) || 'Gemini API request failed');\n  }\n  const result = await response.json();\n  const jsonText = (_result$candidates = result.candidates) === null || _result$candidates === void 0 ? void 0 : (_result$candidates$ = _result$candidates[0]) === null || _result$candidates$ === void 0 ? void 0 : (_result$candidates$$c = _result$candidates$.content) === null || _result$candidates$$c === void 0 ? void 0 : (_result$candidates$$c2 = _result$candidates$$c.parts) === null || _result$candidates$$c2 === void 0 ? void 0 : (_result$candidates$$c3 = _result$candidates$$c2[0]) === null || _result$candidates$$c3 === void 0 ? void 0 : _result$candidates$$c3.text;\n  if (!jsonText) {\n    throw new Error('Invalid API response structure from Gemini.');\n  }\n  return JSON.parse(jsonText);\n}\nexport const matchProjectsWithJD = async (jobDescription, projects) => {\n  if (!jobDescription || projects.length === 0) return [];\n  const projectListString = projects.map(p => `[${p.id}] ${p.name}: ${p.description} (Tech Stack: ${p.tech_stack.join(', ')})`).join('\\n');\n  const systemPrompt = \"You are a Resume Project Matching AI. Your task is to analyze the Job Description (JD) and the provided list of user projects. Select the top 3 projects that are most relevant to the JD. For each selected project, provide a concise, tailored justification (max 2 sentences) explaining *why* it is a perfect match. Return the result as a strict JSON array.\";\n  const userPrompt = `JOB DESCRIPTION:\\n---\\n${jobDescription}\\n---\\n\\nAVAILABLE PROJECTS:\\n---\\n${projectListString}\\n---\\n\\nSelect the top 3 most relevant projects and provide the justification.`;\n  const responseSchema = {\n    type: \"ARRAY\",\n    items: {\n      type: \"OBJECT\",\n      properties: {\n        \"id\": {\n          \"type\": \"STRING\"\n        },\n        \"name\": {\n          \"type\": \"STRING\"\n        },\n        \"justification\": {\n          \"type\": \"STRING\"\n        }\n      },\n      required: [\"id\", \"name\", \"justification\"]\n    }\n  };\n  const matchedResults = await callGeminiAPI(userPrompt, systemPrompt, responseSchema);\n  return matchedResults.map(match => {\n    const originalProject = projects.find(p => p.id === match.id);\n    return originalProject ? {\n      ...originalProject,\n      justification: match.justification\n    } : null;\n  }).filter(p => p !== null);\n};\nexport const getKeywordsFromJD = async jobDescription => {\n  if (!jobDescription) return [];\n  const systemPrompt = \"You are an expert resume keyword analyzer. Analyze the provided Job Description (JD) and extract the top 10-15 most important technical skills, soft skills, and qualifications. Return these as a simple JSON array of strings.\";\n  const userPrompt = `JOB DESCRIPTION:\\n---\\n${jobDescription}\\n---\\n\\nExtract the top 10-15 keywords and return them as a JSON array of strings.`;\n  const responseSchema = {\n    type: \"ARRAY\",\n    items: {\n      type: \"STRING\"\n    }\n  };\n  return await callGeminiAPI(userPrompt, systemPrompt, responseSchema);\n};\nexport const fetchGitHubData = async username => {\n  if (!username) throw new Error(\"GitHub username is required.\");\n  const profileRes = await fetch(`https://api.github.com/users/${username}`);\n  if (!profileRes.ok) throw new Error(`GitHub user not found: ${username}`);\n  const profileData = await profileRes.json();\n  const reposRes = await fetch(profileData.repos_url);\n  if (!reposRes.ok) throw new Error(`Could not fetch repos for ${username}`);\n  const reposData = await reposRes.json();\n  const profile = {\n    name: profileData.name || username,\n    summary: profileData.bio || '',\n    github: username\n  };\n  const repos = reposData.sort((a, b) => new Date(b.pushed_at) - new Date(a.pushed_at)).map(repo => ({\n    id: repo.id.toString(),\n    name: repo.name,\n    description: repo.description || 'No description provided.',\n    tech_stack: [repo.language, ...repo.topics].filter(Boolean),\n    repo_url: repo.html_url.replace('https://', '')\n  }));\n  return {\n    profile,\n    repos\n  };\n};\nexport const getReadmeContent = async (githubUsername, repoName) => {\n  const response = await fetch(`https://api.github.com/repos/${githubUsername}/${repoName}/readme`);\n  if (!response.ok) {\n    if (response.status === 404) {\n      return \"No README file found for this repository.\";\n    }\n    throw new Error(`Could not fetch README for ${repoName}`);\n  }\n  const data = await response.json();\n  // The content is base64 encoded, so we need to decode it.\n  return atob(data.content);\n};\nexport const generateProjectHighlights = async (project, readmeContent, jobDescription) => {\n  if (!jobDescription) {\n    throw new Error(\"Job Description is required to generate highlights.\");\n  }\n  const systemPrompt = `You are an expert resume writer. Your task is to generate 2-3 crisp, concise, and impactful bullet points for a resume project section. The bullet points must highlight the project's accomplishments and technologies, tailored specifically to the provided job description. Start each bullet point with a strong action verb. Be direct and to the point.`;\n  const userPrompt = `\nJob Description:\n---\n${jobDescription}\n---\n\nProject Name: ${project.name}\nProject Description: ${project.description}\nProject README Content:\n---\n${readmeContent}\n---\n\nBased on all the provided information, generate 2-3 resume bullet points that make this project sound as relevant as possible for the job. Return the result as a JSON array of strings.`;\n  const responseSchema = {\n    type: \"ARRAY\",\n    items: {\n      type: \"STRING\"\n    }\n  };\n  return await callGeminiAPI(userPrompt, systemPrompt, responseSchema);\n};","map":{"version":3,"names":["GEMINI_API_KEY","process","env","REACT_APP_GEMINI_API_KEY","API_BASE_URL","MODEL_NAME","callGeminiAPI","prompt","systemPrompt","responseSchema","_result$candidates","_result$candidates$","_result$candidates$$c","_result$candidates$$c2","_result$candidates$$c3","Error","apiUrl","payload","contents","parts","text","systemInstruction","generationConfig","responseMimeType","response","fetch","method","headers","body","JSON","stringify","ok","_error$error","error","json","message","result","jsonText","candidates","content","parse","matchProjectsWithJD","jobDescription","projects","length","projectListString","map","p","id","name","description","tech_stack","join","userPrompt","type","items","properties","required","matchedResults","match","originalProject","find","justification","filter","getKeywordsFromJD","fetchGitHubData","username","profileRes","profileData","reposRes","repos_url","reposData","profile","summary","bio","github","repos","sort","a","b","Date","pushed_at","repo","toString","language","topics","Boolean","repo_url","html_url","replace","getReadmeContent","githubUsername","repoName","status","data","atob","generateProjectHighlights","project","readmeContent"],"sources":["C:/Users/ragha/OneDrive/Desktop/resume builder/ai-resume-generator/client/src/services/api.js"],"sourcesContent":["const GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\r\nconst API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/';\r\nconst MODEL_NAME = 'gemini-pro-latest';\r\n\r\nasync function callGeminiAPI(prompt, systemPrompt, responseSchema) {\r\n    if (!GEMINI_API_KEY) {\r\n        throw new Error('Gemini API Key is missing. Please check your .env file.');\r\n    }\r\n    const apiUrl = `${API_BASE_URL}${MODEL_NAME}:generateContent?key=${GEMINI_API_KEY}`;\r\n\r\n    const payload = {\r\n        contents: [{ parts: [{ text: prompt }] }],\r\n        systemInstruction: { parts: [{ text: systemPrompt }] },\r\n        generationConfig: {\r\n            responseMimeType: \"application/json\",\r\n            responseSchema: responseSchema\r\n        }\r\n    };\r\n\r\n    const response = await fetch(apiUrl, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(payload)\r\n    });\r\n\r\n    if (!response.ok) {\r\n        const error = await response.json();\r\n        throw new Error(error.error?.message || 'Gemini API request failed');\r\n    }\r\n\r\n    const result = await response.json();\r\n    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;\r\n\r\n    if (!jsonText) {\r\n        throw new Error('Invalid API response structure from Gemini.');\r\n    }\r\n    return JSON.parse(jsonText);\r\n}\r\n\r\nexport const matchProjectsWithJD = async (jobDescription, projects) => {\r\n    if (!jobDescription || projects.length === 0) return [];\r\n\r\n    const projectListString = projects.map(p =>\r\n        `[${p.id}] ${p.name}: ${p.description} (Tech Stack: ${p.tech_stack.join(', ')})`\r\n    ).join('\\n');\r\n\r\n    const systemPrompt = \"You are a Resume Project Matching AI. Your task is to analyze the Job Description (JD) and the provided list of user projects. Select the top 3 projects that are most relevant to the JD. For each selected project, provide a concise, tailored justification (max 2 sentences) explaining *why* it is a perfect match. Return the result as a strict JSON array.\";\r\n    const userPrompt = `JOB DESCRIPTION:\\n---\\n${jobDescription}\\n---\\n\\nAVAILABLE PROJECTS:\\n---\\n${projectListString}\\n---\\n\\nSelect the top 3 most relevant projects and provide the justification.`;\r\n\r\n    const responseSchema = {\r\n        type: \"ARRAY\",\r\n        items: {\r\n            type: \"OBJECT\",\r\n            properties: {\r\n                \"id\": { \"type\": \"STRING\" },\r\n                \"name\": { \"type\": \"STRING\" },\r\n                \"justification\": { \"type\": \"STRING\" }\r\n            },\r\n            required: [\"id\", \"name\", \"justification\"]\r\n        }\r\n    };\r\n\r\n    const matchedResults = await callGeminiAPI(userPrompt, systemPrompt, responseSchema);\r\n    return matchedResults.map(match => {\r\n        const originalProject = projects.find(p => p.id === match.id);\r\n        return originalProject ? { ...originalProject, justification: match.justification } : null;\r\n    }).filter(p => p !== null);\r\n};\r\n\r\nexport const getKeywordsFromJD = async (jobDescription) => {\r\n    if (!jobDescription) return [];\r\n\r\n    const systemPrompt = \"You are an expert resume keyword analyzer. Analyze the provided Job Description (JD) and extract the top 10-15 most important technical skills, soft skills, and qualifications. Return these as a simple JSON array of strings.\";\r\n    const userPrompt = `JOB DESCRIPTION:\\n---\\n${jobDescription}\\n---\\n\\nExtract the top 10-15 keywords and return them as a JSON array of strings.`;\r\n\r\n    const responseSchema = { type: \"ARRAY\", items: { type: \"STRING\" } };\r\n    return await callGeminiAPI(userPrompt, systemPrompt, responseSchema);\r\n};\r\n\r\nexport const fetchGitHubData = async (username) => {\r\n    if (!username) throw new Error(\"GitHub username is required.\");\r\n\r\n    const profileRes = await fetch(`https://api.github.com/users/${username}`);\r\n    if (!profileRes.ok) throw new Error(`GitHub user not found: ${username}`);\r\n    const profileData = await profileRes.json();\r\n\r\n    const reposRes = await fetch(profileData.repos_url);\r\n    if (!reposRes.ok) throw new Error(`Could not fetch repos for ${username}`);\r\n    const reposData = await reposRes.json();\r\n\r\n    const profile = {\r\n        name: profileData.name || username,\r\n        summary: profileData.bio || '',\r\n        github: username,\r\n    };\r\n\r\n    const repos = reposData\r\n        .sort((a, b) => new Date(b.pushed_at) - new Date(a.pushed_at))\r\n        .map(repo => ({\r\n            id: repo.id.toString(),\r\n            name: repo.name,\r\n            description: repo.description || 'No description provided.',\r\n            tech_stack: [repo.language, ...repo.topics].filter(Boolean),\r\n            repo_url: repo.html_url.replace('https://', ''),\r\n        }));\r\n\r\n    return { profile, repos };\r\n};\r\n\r\nexport const getReadmeContent = async (githubUsername, repoName) => {\r\n    const response = await fetch(`https://api.github.com/repos/${githubUsername}/${repoName}/readme`);\r\n    if (!response.ok) {\r\n        if (response.status === 404) {\r\n            return \"No README file found for this repository.\";\r\n        }\r\n        throw new Error(`Could not fetch README for ${repoName}`);\r\n    }\r\n    const data = await response.json();\r\n    // The content is base64 encoded, so we need to decode it.\r\n    return atob(data.content);\r\n};\r\n\r\nexport const generateProjectHighlights = async (project, readmeContent, jobDescription) => {\r\n    if (!jobDescription) {\r\n        throw new Error(\"Job Description is required to generate highlights.\");\r\n    }\r\n\r\n    const systemPrompt = `You are an expert resume writer. Your task is to generate 2-3 crisp, concise, and impactful bullet points for a resume project section. The bullet points must highlight the project's accomplishments and technologies, tailored specifically to the provided job description. Start each bullet point with a strong action verb. Be direct and to the point.`;\r\n\r\n    const userPrompt = `\r\nJob Description:\r\n---\r\n${jobDescription}\r\n---\r\n\r\nProject Name: ${project.name}\r\nProject Description: ${project.description}\r\nProject README Content:\r\n---\r\n${readmeContent}\r\n---\r\n\r\nBased on all the provided information, generate 2-3 resume bullet points that make this project sound as relevant as possible for the job. Return the result as a JSON array of strings.`;\r\n\r\n    const responseSchema = { type: \"ARRAY\", items: { type: \"STRING\" } };\r\n    return await callGeminiAPI(userPrompt, systemPrompt, responseSchema);\r\n};\r\n"],"mappings":"AAAA,MAAMA,cAAc,GAAGC,OAAO,CAACC,GAAG,CAACC,wBAAwB;AAC3D,MAAMC,YAAY,GAAG,0DAA0D;AAC/E,MAAMC,UAAU,GAAG,mBAAmB;AAEtC,eAAeC,aAAaA,CAACC,MAAM,EAAEC,YAAY,EAAEC,cAAc,EAAE;EAAA,IAAAC,kBAAA,EAAAC,mBAAA,EAAAC,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA;EAC/D,IAAI,CAACd,cAAc,EAAE;IACjB,MAAM,IAAIe,KAAK,CAAC,yDAAyD,CAAC;EAC9E;EACA,MAAMC,MAAM,GAAG,GAAGZ,YAAY,GAAGC,UAAU,wBAAwBL,cAAc,EAAE;EAEnF,MAAMiB,OAAO,GAAG;IACZC,QAAQ,EAAE,CAAC;MAAEC,KAAK,EAAE,CAAC;QAAEC,IAAI,EAAEb;MAAO,CAAC;IAAE,CAAC,CAAC;IACzCc,iBAAiB,EAAE;MAAEF,KAAK,EAAE,CAAC;QAAEC,IAAI,EAAEZ;MAAa,CAAC;IAAE,CAAC;IACtDc,gBAAgB,EAAE;MACdC,gBAAgB,EAAE,kBAAkB;MACpCd,cAAc,EAAEA;IACpB;EACJ,CAAC;EAED,MAAMe,QAAQ,GAAG,MAAMC,KAAK,CAACT,MAAM,EAAE;IACjCU,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MAAE,cAAc,EAAE;IAAmB,CAAC;IAC/CC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACb,OAAO;EAChC,CAAC,CAAC;EAEF,IAAI,CAACO,QAAQ,CAACO,EAAE,EAAE;IAAA,IAAAC,YAAA;IACd,MAAMC,KAAK,GAAG,MAAMT,QAAQ,CAACU,IAAI,CAAC,CAAC;IACnC,MAAM,IAAInB,KAAK,CAAC,EAAAiB,YAAA,GAAAC,KAAK,CAACA,KAAK,cAAAD,YAAA,uBAAXA,YAAA,CAAaG,OAAO,KAAI,2BAA2B,CAAC;EACxE;EAEA,MAAMC,MAAM,GAAG,MAAMZ,QAAQ,CAACU,IAAI,CAAC,CAAC;EACpC,MAAMG,QAAQ,IAAA3B,kBAAA,GAAG0B,MAAM,CAACE,UAAU,cAAA5B,kBAAA,wBAAAC,mBAAA,GAAjBD,kBAAA,CAAoB,CAAC,CAAC,cAAAC,mBAAA,wBAAAC,qBAAA,GAAtBD,mBAAA,CAAwB4B,OAAO,cAAA3B,qBAAA,wBAAAC,sBAAA,GAA/BD,qBAAA,CAAiCO,KAAK,cAAAN,sBAAA,wBAAAC,sBAAA,GAAtCD,sBAAA,CAAyC,CAAC,CAAC,cAAAC,sBAAA,uBAA3CA,sBAAA,CAA6CM,IAAI;EAElE,IAAI,CAACiB,QAAQ,EAAE;IACX,MAAM,IAAItB,KAAK,CAAC,6CAA6C,CAAC;EAClE;EACA,OAAOc,IAAI,CAACW,KAAK,CAACH,QAAQ,CAAC;AAC/B;AAEA,OAAO,MAAMI,mBAAmB,GAAG,MAAAA,CAAOC,cAAc,EAAEC,QAAQ,KAAK;EACnE,IAAI,CAACD,cAAc,IAAIC,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;EAEvD,MAAMC,iBAAiB,GAAGF,QAAQ,CAACG,GAAG,CAACC,CAAC,IACpC,IAAIA,CAAC,CAACC,EAAE,KAAKD,CAAC,CAACE,IAAI,KAAKF,CAAC,CAACG,WAAW,iBAAiBH,CAAC,CAACI,UAAU,CAACC,IAAI,CAAC,IAAI,CAAC,GACjF,CAAC,CAACA,IAAI,CAAC,IAAI,CAAC;EAEZ,MAAM5C,YAAY,GAAG,qWAAqW;EAC1X,MAAM6C,UAAU,GAAG,0BAA0BX,cAAc,sCAAsCG,iBAAiB,iFAAiF;EAEnM,MAAMpC,cAAc,GAAG;IACnB6C,IAAI,EAAE,OAAO;IACbC,KAAK,EAAE;MACHD,IAAI,EAAE,QAAQ;MACdE,UAAU,EAAE;QACR,IAAI,EAAE;UAAE,MAAM,EAAE;QAAS,CAAC;QAC1B,MAAM,EAAE;UAAE,MAAM,EAAE;QAAS,CAAC;QAC5B,eAAe,EAAE;UAAE,MAAM,EAAE;QAAS;MACxC,CAAC;MACDC,QAAQ,EAAE,CAAC,IAAI,EAAE,MAAM,EAAE,eAAe;IAC5C;EACJ,CAAC;EAED,MAAMC,cAAc,GAAG,MAAMpD,aAAa,CAAC+C,UAAU,EAAE7C,YAAY,EAAEC,cAAc,CAAC;EACpF,OAAOiD,cAAc,CAACZ,GAAG,CAACa,KAAK,IAAI;IAC/B,MAAMC,eAAe,GAAGjB,QAAQ,CAACkB,IAAI,CAACd,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKW,KAAK,CAACX,EAAE,CAAC;IAC7D,OAAOY,eAAe,GAAG;MAAE,GAAGA,eAAe;MAAEE,aAAa,EAAEH,KAAK,CAACG;IAAc,CAAC,GAAG,IAAI;EAC9F,CAAC,CAAC,CAACC,MAAM,CAAChB,CAAC,IAAIA,CAAC,KAAK,IAAI,CAAC;AAC9B,CAAC;AAED,OAAO,MAAMiB,iBAAiB,GAAG,MAAOtB,cAAc,IAAK;EACvD,IAAI,CAACA,cAAc,EAAE,OAAO,EAAE;EAE9B,MAAMlC,YAAY,GAAG,kOAAkO;EACvP,MAAM6C,UAAU,GAAG,0BAA0BX,cAAc,qFAAqF;EAEhJ,MAAMjC,cAAc,GAAG;IAAE6C,IAAI,EAAE,OAAO;IAAEC,KAAK,EAAE;MAAED,IAAI,EAAE;IAAS;EAAE,CAAC;EACnE,OAAO,MAAMhD,aAAa,CAAC+C,UAAU,EAAE7C,YAAY,EAAEC,cAAc,CAAC;AACxE,CAAC;AAED,OAAO,MAAMwD,eAAe,GAAG,MAAOC,QAAQ,IAAK;EAC/C,IAAI,CAACA,QAAQ,EAAE,MAAM,IAAInD,KAAK,CAAC,8BAA8B,CAAC;EAE9D,MAAMoD,UAAU,GAAG,MAAM1C,KAAK,CAAC,gCAAgCyC,QAAQ,EAAE,CAAC;EAC1E,IAAI,CAACC,UAAU,CAACpC,EAAE,EAAE,MAAM,IAAIhB,KAAK,CAAC,0BAA0BmD,QAAQ,EAAE,CAAC;EACzE,MAAME,WAAW,GAAG,MAAMD,UAAU,CAACjC,IAAI,CAAC,CAAC;EAE3C,MAAMmC,QAAQ,GAAG,MAAM5C,KAAK,CAAC2C,WAAW,CAACE,SAAS,CAAC;EACnD,IAAI,CAACD,QAAQ,CAACtC,EAAE,EAAE,MAAM,IAAIhB,KAAK,CAAC,6BAA6BmD,QAAQ,EAAE,CAAC;EAC1E,MAAMK,SAAS,GAAG,MAAMF,QAAQ,CAACnC,IAAI,CAAC,CAAC;EAEvC,MAAMsC,OAAO,GAAG;IACZvB,IAAI,EAAEmB,WAAW,CAACnB,IAAI,IAAIiB,QAAQ;IAClCO,OAAO,EAAEL,WAAW,CAACM,GAAG,IAAI,EAAE;IAC9BC,MAAM,EAAET;EACZ,CAAC;EAED,MAAMU,KAAK,GAAGL,SAAS,CAClBM,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,IAAIC,IAAI,CAACD,CAAC,CAACE,SAAS,CAAC,GAAG,IAAID,IAAI,CAACF,CAAC,CAACG,SAAS,CAAC,CAAC,CAC7DnC,GAAG,CAACoC,IAAI,KAAK;IACVlC,EAAE,EAAEkC,IAAI,CAAClC,EAAE,CAACmC,QAAQ,CAAC,CAAC;IACtBlC,IAAI,EAAEiC,IAAI,CAACjC,IAAI;IACfC,WAAW,EAAEgC,IAAI,CAAChC,WAAW,IAAI,0BAA0B;IAC3DC,UAAU,EAAE,CAAC+B,IAAI,CAACE,QAAQ,EAAE,GAAGF,IAAI,CAACG,MAAM,CAAC,CAACtB,MAAM,CAACuB,OAAO,CAAC;IAC3DC,QAAQ,EAAEL,IAAI,CAACM,QAAQ,CAACC,OAAO,CAAC,UAAU,EAAE,EAAE;EAClD,CAAC,CAAC,CAAC;EAEP,OAAO;IAAEjB,OAAO;IAAEI;EAAM,CAAC;AAC7B,CAAC;AAED,OAAO,MAAMc,gBAAgB,GAAG,MAAAA,CAAOC,cAAc,EAAEC,QAAQ,KAAK;EAChE,MAAMpE,QAAQ,GAAG,MAAMC,KAAK,CAAC,gCAAgCkE,cAAc,IAAIC,QAAQ,SAAS,CAAC;EACjG,IAAI,CAACpE,QAAQ,CAACO,EAAE,EAAE;IACd,IAAIP,QAAQ,CAACqE,MAAM,KAAK,GAAG,EAAE;MACzB,OAAO,2CAA2C;IACtD;IACA,MAAM,IAAI9E,KAAK,CAAC,8BAA8B6E,QAAQ,EAAE,CAAC;EAC7D;EACA,MAAME,IAAI,GAAG,MAAMtE,QAAQ,CAACU,IAAI,CAAC,CAAC;EAClC;EACA,OAAO6D,IAAI,CAACD,IAAI,CAACvD,OAAO,CAAC;AAC7B,CAAC;AAED,OAAO,MAAMyD,yBAAyB,GAAG,MAAAA,CAAOC,OAAO,EAAEC,aAAa,EAAExD,cAAc,KAAK;EACvF,IAAI,CAACA,cAAc,EAAE;IACjB,MAAM,IAAI3B,KAAK,CAAC,qDAAqD,CAAC;EAC1E;EAEA,MAAMP,YAAY,GAAG,gWAAgW;EAErX,MAAM6C,UAAU,GAAG;AACvB;AACA;AACA,EAAEX,cAAc;AAChB;AACA;AACA,gBAAgBuD,OAAO,CAAChD,IAAI;AAC5B,uBAAuBgD,OAAO,CAAC/C,WAAW;AAC1C;AACA;AACA,EAAEgD,aAAa;AACf;AACA;AACA,yLAAyL;EAErL,MAAMzF,cAAc,GAAG;IAAE6C,IAAI,EAAE,OAAO;IAAEC,KAAK,EAAE;MAAED,IAAI,EAAE;IAAS;EAAE,CAAC;EACnE,OAAO,MAAMhD,aAAa,CAAC+C,UAAU,EAAE7C,YAAY,EAAEC,cAAc,CAAC;AACxE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}